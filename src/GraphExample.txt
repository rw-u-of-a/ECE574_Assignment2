#include <iostream>
#include <map>
#include "vmodule.h"

using namespace std;

map<string, map<int, double>> make_latencies(){
    return {{"REG",
                    {{1, 2.616},
                            {2, 2.644},
                            {8, 2.879},
                            {16, 3.061},
                            {32, 3.602},
                            {64, 3.966}}},
            {"ADD",
                    {{1, 2.704},
                            {2, 3.713},
                            {8, 4.924},
                            {16, 5.638},
                            {32, 7.270},
                            {64, 9.566}}},
            {"SUB",
                    {{1, 3.024},
                            {2, 3.412},
                            {8, 4.890},
                            {16, 5.569},
                            {32, 7.253},
                            {64, 9.566}}},
            {"MUL",
                    {{1, 2.438},
                            {2, 3.651},
                            {8, 7.453},
                            {16, 7.811},
                            {32, 12.395},
                            {64, 15.354}}},
            {"COMP",
                    {{1, 3.031},
                            {2, 3.934},
                            {8, 5.949},
                            {16, 6.256},
                            {32, 7.264},
                            {64, 8.416}}},
            {"MUX2x1",
                    {{1, 4.083},
                            {2, 4.115},
                            {8, 4.815},
                            {16, 5.623},
                            {32, 8.079},
                            {64, 8.766}}},
            {"SHR",
                    {{1, 3.644},
                            {2, 4.007},
                            {8, 5.178},
                            {16, 6.460},
                            {32, 8.819},
                            {64, 11.095}}},
            {"SHL",
                    {{1, 3.614},
                            {2, 3.980},
                            {8, 5.152},
                            {16, 6.549},
                            {32, 8.565},
                            {64, 11.220}}},
            {"DIV",
                    {{1, 0.619},
                            {2, 2.144},
                            {8, 15.439},
                            {16, 33.093},
                            {32, 86.312},
                            {64, 243.233}}},
            {"MOD",
                    {{1, 0.758},
                            {2, 2.149},
                            {8, 16.078},
                            {16, 35.563},
                            {32, 88.142},
                            {64, 250.583}}},
            {"INC",
                    {{1, 1.792},
                            {2, 2.218},
                            {8, 3.111},
                            {16, 3.471},
                            {32, 4.347},
                            {64, 6.200}}},
            {"DEC",
                    {{1, 1.792},
                            {2, 2.218},
                            {8, 3.108},
                            {16, 3.701},
                            {32, 4.685},
                            {64, 6.503}}}};
};

int GraphExample(){
    vmodule G;
    map<string, map<int, double>> latencies;
    latencies = make_latencies();


    // input Int8 a, b, c
    G.add_wire("a", true, 8);
    G.wires["a"]->is_completed = true;
    G.add_wire("b", true, 8);
    G.wires["b"]->is_completed = true;
    G.add_wire("c", true, 8);
    G.wires["c"]->is_completed = true;

    // output Int8 z
    G.add_wire("z", true, 8);

    // output Int16 x
    G.add_wire("x", true, 16);

    // wire Int8 d, e
    G.add_wire("d", true, 8);
    G.add_wire("e", true, 8);

    // wire Int16 f, g
    G.add_wire("f", true, 16);
    G.add_wire("g", true, 16);

    // wire Int16 zwire, xwire
    G.add_wire("zwire", true, 16);
    G.add_wire("xwire", true, 16);

    // d = a + b
    G.add_component("ADD_1", latencies["ADD"][8]);
    G.wire_to_component("a", "ADD_1");
    G.wire_to_component("b", "ADD_1");
    G.wire_from_component("d", "ADD_1");

    // e = a + c
    G.add_component("ADD_2", latencies["ADD"][8]);
    G.wire_to_component("a", "ADD_2");
    G.wire_to_component("c", "ADD_2");
    G.wire_from_component("e", "ADD_2");

    // g = d > e
    G.add_component("COMP_1", latencies["COMP"][8]);
    G.wire_to_component("d", "COMP_1");
    G.wire_to_component("e", "COMP_1");
    G.wire_from_component("g", "COMP_1");

    // zwire = g ? d : e
    G.add_component("MUX2x1_1", latencies["MUX2x1"][8]);
    G.wire_to_component("g", "MUX2x1_1");
    G.wire_to_component("d", "MUX2x1_1");
    G.wire_to_component("e", "MUX2x1_1");
    G.wire_from_component("zwire", "MUX2x1_1");

    // z = zwire
    G.add_component("REG_1", latencies["REG"][8]);
    G.wire_to_component("zwire", "REG_1");
    G.wire_from_component("z", "REG_1");
    G.make_register("REG_1");

    // f = a * c
    G.add_component("MUL_1", latencies["MUL"][8]);
    G.wire_to_component("a", "MUL_1");
    G.wire_to_component("c", "MUL_1");
    G.wire_from_component("f", "MUL_1");

    // xwire = f - d
    G.add_component("SUB_1", latencies["SUB"][16]);
    G.wire_to_component("f", "SUB_1");
    G.wire_to_component("d", "SUB_1");
    G.wire_from_component("xwire", "SUB_1");

    // x = xwire
    G.add_component("REG_2", latencies["REG"][16]);
    G.wire_to_component("xwire", "REG_2");
    G.wire_from_component("x", "REG_2");
    G.make_register("REG_2");

    while (G.num_incomplete > 0)
        for (auto comp_itr : G.components)
            G.propagate(comp_itr.first);
    cout << G.max_latency << "\n";
    return 0;
}